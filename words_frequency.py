#!/usr/bin/env python3

"""Модуль os - множество функций для работы с операционной системой.

Поведение функций, как правило, не зависит от ОС, поэтому программы,
написанные с использованием этого модуля остаются переносимыми на разные
платформы. Как правило программы на python одинаково хорошо работают как
на Linux, так и на Windows и конечно же Mac.
"""
import os


"""Модуль argparse - модуль для работы с агрументами командной строки.

Назначение модуля - обработка опций и аргументов командной строки, с
которой вызывается скрипт.
"""
import argparse


"""Модуль re - модуль для работы с регулярными выражениями.

Регулярные выражения это вообще довольно объемная тема, но в двух словах,
регулярки - это последовательности символов, используемая для поиска и
замены текста в строке или файле.

Более подробно можно почитать тут:
- раз - https://tproger.ru/translations/regular-expression-python
- два - https://habrahabr.ru/post/115825
"""
import re


"""Модуль collections - модуль, предоставляющий специальные типы данных
на основе словарей, кортежей, множеств и списков.

В частности, collections.Counter - это особый вид словаря, который позволяет
считать количество неизменяемых объектов, в большинстве случаев - строк.
После применения этого типа данных к строке, получится словарь, у которого в
качестве ключей будут символы строки, а в качестве значений - частота этих
симоволов. Например:

Строка: `Олег, где ночлег?`
Она содержит: 17 символов, из них:
буква               'е' - 3 штуки
буква               'г' - 3 штуки
буква               'л' - 2 штуки
пробел              ' ' - 2 штуки
буква               'н' - 1 штука
буква               'о' - 1 штука
буква               'д' - 1 штука
буква               'ч' - 1 штука
запятая             ',' - 1 штука
вопросительный знак '?' - 1 штука
буква               'О' - 1 штука,

тогда результатом применения collections.Counter будет словарь:

{
    ' ': 2,
    ',': 1,
    '?': 1,
    'О': 1,
    'г': 3,
    'д': 1,
    'е': 3,
    'л': 2,
    'н': 1,
    'о': 1,
    'ч': 1
}
"""
from collections import Counter

"""Это наше собственное исключение, используемое когда мы не можем найти файл.

Как мы помним все новые исключение наследуются от класса Exception - здест так же.
Используем функцию конструктор __init__ для определения того, какое сообщение
увидит пользователь в случае, если файл не будет найден.
"""
class FileNotFound(Exception):
    def __init__(self, filename):
        message = "File: {0} not found".format(filename)

        # super() - это обращение к родительcкому классу, т.е. - классу Exception.
        # У класса Exception уже есть метод конструктор __init__, но мы его переопределяем.
        # А чтобы все таки вызвать его(он делает многие полезные вещи, которые не делаем
        # мы в своей функции) используется такой синтаксис, как указано ниже
        super().__init__(message)


"""Загрузка содержимого файла. Не правда ли, говорящее название:)
"""
def load_file_content(filepath):
    # Если файл не найдет, выкидываем наше исключение
    if not os.path.exists(filepath):
        raise FileNotFound(filepath)

    # with - это менеджер контекста. Не будем пока вдаваться в подробности его
    # работы. Запомним одно в переменную `opened_file` записывается экземпляр класса для
    # работы с операциями ввода-вывода.

    # Функция open(filepath, "r") открывает файл в режиме чтения(режим - "r") и
    # возвращает экземпляр класса с некоторыми методами, в том числе - read()

    # Метод read() просто возвращает все содержимое файла(читает все строки)
    with open(filepath, "r") as opened_file:
        return opened_file.read()


"""Функция возвращает список слов из текста `text`, которые строго больше длины
`min_length`.
"""
def extract_words(text, min_length=None, ignore_case=False):
    # Регулярное выражение - "(\w+)" означает, что нужно найти все слова(не знаки,
    # не цифры, ничего, только слова)

    # Функция findall применяет данное регулярное выражение ко всему тексту, это
    # означает, что поиск не прекратится после нахождения первого совпадения, как
    # это происходит при использовании функции find

    # На выходе в переменной `words` будет список всех слов из данного текста
    words = re.findall(r"(\w+)", text, re.UNICODE)

    if ignore_case:
        words = [word.lower() for word in words]

    if min_length:
        # Функция filter оставляет в последовательности только те элементы,
        # на которых вызов внутренней функции дал True

        # В данном случае в качестве внутренней функции используется
        # анонимная функция `lambda word: len(word) > min_length`.
        # Это такая же функция как и все остальные, только данная функция
        # не имеет имени.
        words = filter(lambda word: len(word) > min_length, words)

    # Так как функция filter на выходе дает не  список а генератор, то убедимся,
    # что функция все же возвращает список
    return list(words)


def main():
    """Ниже - пример определения парсера аргументов командной строки.
    Данные строки не требуют комментариев, так как все довольно прозрачно.
    """
    description = "Get most frequent words from FILENAME"
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument(
        "-f", "--filepath",
        required=True,
        help="File path"
    )
    parser.add_argument(
        "-n",
        help="Number of words to print. Default: 10",
        default=10,
        type=int
    )
    parser.add_argument(
        "-m", "--min-length",
        type=int,
        help="Minimum word length for evaluation. Default: None"
    )
    parser.add_argument(
        "-i", "--ignore-case",
        action="store_true",
        help="Ignoring register of word.Default: None"
    )
    # В переменной args будет находится экземпляр класс парсера, в котором уже
    # будут все полученные аргументы
    args = parser.parse_args()

    text = load_file_content(args.filepath)
    words = extract_words(text, args.min_length, args.ignore_case)

    # Применяем collections.Counter ко всему нашему тексту как это было в примере
    # выше
    most_frequent_words = Counter(words)

    # Так как в значениях словаря находятся частоты слов, сложив их все
    # можно получить количество всех слов в тексте(указанной длины, если длина задана)
    number_of_words = sum(most_frequent_words.values())

    # Метод most_common типа данных collections.Counter при передаче ему в
    # качестве аргумента None выведет вообще все слова, которые у него есть,
    # поэтому если пользователь ввел число 0 -> выведем вообще все слова.

    # P.S.: при приведении нуля к булевому типу получается False
    amount = args.n or None

    print_format = "{0:<6} {1:<25} {2:>4}"

    print(print_format.format("#", "Word", "Freq"))
    print("-" * 37)

    # Функция enumerate возвращает список кортежей, где первым элементом
    # является порядковый номер элемента в списке, а вторым - сам элемент
    for item in enumerate(most_frequent_words.most_common(amount)):
        print(print_format.format(
            item[0] + 1,
            item[1][0].ljust(25, "."),
            item[1][1])
        )

    print("-" * 37)
    print("There is {0} words ".format(number_of_words), end="")

    if args.min_length:
        print("of length {0}".format(args.min_length))
    else:
        print()


if __name__ == "__main__":
    main()
